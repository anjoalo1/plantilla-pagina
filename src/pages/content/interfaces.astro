---
import Layout from '../../layouts/Layout.astro';
import Article from '../../components/Articlep.astro';
import Code from '../../components/Code.astro';
const typelang ="line-numbers language-java";
const codigo1 =
`
import java.util.ArrayList;
import java.util.Collection;

public class Main {
    public static void main(String[] args) {
        // Crear una colección de enteros usando ArrayList
        Collection<Integer> numeros = new ArrayList<>();

        // Agregar elementos a la colección
        numeros.add(1);
        numeros.add(2);
        numeros.add(3);

        // Verificar si la colección contiene un elemento
        boolean contieneDos = numeros.contains(2);
        System.out.println("La colección contiene el número 2: " + contieneDos);

        // Obtener el tamaño de la colección
        int tamaño = numeros.size();
        System.out.println("Tamaño de la colección: " + tamaño);

        // Eliminar un elemento de la colección
        numeros.remove(1);

        // Verificar si la colección está vacía
        boolean estaVacia = numeros.isEmpty();
        System.out.println("La colección está vacía: " + estaVacia);

        // Iterar a través de la colección
        for (Integer numero : numeros) {
            System.out.println(numero);
        }
    }
}

`;
const codigo2 =`import java.util.ArrayList;

public class ArrayListExample {
    public static void main(String[] args) {
        // Crear un ArrayList de cadenas
        ArrayList<String> nombres = new ArrayList<>();

        // Agregar elementos al ArrayList
        nombres.add("Alice");
        nombres.add("Bob");
        nombres.add("Charlie");

        // Acceder a elementos por índice
        String primerNombre = nombres.get(0);
        System.out.println("Primer nombre: " + primerNombre);

        // Iterar a través de los elementos
        for (String nombre : nombres) {
            System.out.println(nombre);
        }
    }
}
`;
const codigo3 =`import java.util.HashMap;

public class HashMapExample {
    public static void main(String[] args) {
        // Crear un HashMap con claves y valores de tipo String
        HashMap<String, Integer> edades = new HashMap<>();

        // Agregar elementos al HashMap
        edades.put("Alice", 25);
        edades.put("Bob", 30);
        edades.put("Charlie", 28);

        // Acceder a valores por clave
        int edadDeAlice = edades.get("Alice");
        System.out.println("Edad de Alice: " + edadDeAlice);

        // Iterar a través de las claves y valores
        for (String nombre : edades.keySet()) {
            int edad = edades.get(nombre);
            System.out.println(nombre + ": " + edad + " años");
        }
    }
}
`;
const codigo4 =``;
const codigo5 =``;
const codigo6 =``;
const codigo7 =``;
---

<Layout title="intefa">

    <main>

        <Article>
            <ol class="parrafo">
                <li>
                    <strong>HashMap:</strong> Implementa un mapa no ordenado basado en una tabla hash. Es útil cuando necesitas una estructura de datos para mapear claves a valores y no te importa el orden de las claves.
                </li>
                <li>
                    <strong>LinkedHashMap:</strong> Similar a HashMap, pero mantiene el orden de inserción. Útil cuando necesitas un mapa con claves en un orden específico.
                </li>
                <li>
                    <strong>ConcurrentHashMap:</strong> Una versión optimizada para concurrencia de HashMap que permite el acceso seguro desde múltiples hilos sin bloqueo.
                </li>
                <li>
                    <strong>WeakHashMap:</strong> Un mapa que utiliza referencias débiles para las claves, lo que significa que las claves que no están en uso se pueden eliminar automáticamente.
                </li>
                <li>
                    <strong>IdentityHashMap:</strong> Un mapa que compara las claves por identidad en lugar de por igualdad.
                </li>
                <li>
                    <strong>EnumMap:</strong> Un mapa especializado diseñado para claves de tipo enum.
                </li>
                <li>
                    <strong>BitSet:</strong> Una colección de bits que se puede utilizar para representar conjuntos de elementos como valores booleanos.
                </li>
                <li>
                    <strong>Stack y Queue:</strong> Interfaces que representan pilas y colas, respectivamente. Puedes implementar estas interfaces utilizando LinkedList u otras estructuras de datos.
                </li>
                <li>
                    <strong>ArrayDeque:</strong> Una implementación de doble extremo de la interfaz Deque que puede usarse como pila o cola.
                </li>
                <li>
                    <strong>HashTable:</strong> Similar a HashMap, pero más antiguo y menos utilizado en código moderno debido a su falta de sincronización y otras desventajas en comparación con ConcurrentHashMap.
                </li>
            </ol>
            
        </Article>
        <Article>
            <h1 class="title-h1">Interfaz Collection &lt;E&gt;.</h1>
            <h2 class="title-h2">Ejemplo 1: Usando ArrayList</h2>
            <Code codigo={codigo1} typeLan={typelang}></Code>
        </Article>
        
        <Article>
            <h2 class="title-h2">ArrayList:</h2>
            <Code codigo={codigo2} typeLan={typelang}></Code>
            
        </Article>
        <Article>
            <h2 class="title-h2">HashMap:</h2>
            <Code codigo={codigo3} typeLan={typelang}></Code>
            
        </Article>



    </main>

</Layout>